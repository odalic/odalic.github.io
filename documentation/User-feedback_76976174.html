<!DOCTYPE html>
<html>
    <head>
        <title>ADEQUATE : User feedback</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">ADEQUATE</a></span>
                            </li>
                                                    <li>
                                <span><a href="Odalic_71438906.html">Odalic</a></span>
                            </li>
                                                    <li>
                                <span><a href="ODALIC-Documentation_76973575.html">ODALIC Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Developer-Documentation_76973577.html">Developer Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Server_76975931.html">Server</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            ADEQUATE : User feedback
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Josef Janoušek</span>, last modified on Mai 31, 2017
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p>User can provide several kinds of feedback to the core annotation algorithm. All parts are grouped in the <code>cz.cuni.mff.xrg.odalic.feedbacks.Feedback</code> class. Feedback is a part of Task configuration. Initially (after the Task creation) the feedback is empty. When the algorithm run is finished, user can observe the results and adjust the feedback, which will be considered by algorithm in the next run.</p><h1 id="Userfeedback-Passingthefeedbacktothealgorithm">Passing the feedback to the algorithm</h1><p>Before the execution of the core algorithm, Feedback is adapted by the <code>cz.cuni.mff.xrg.odalic.feedbacks.DefaultFeedbackToConstraintsAdapter</code> (which implements interface <code>cz.cuni.mff.xrg.odalic.feedbacks.FeedbackToConstraintsAdapter</code>) to object of the <code>uk.ac.shef.dcs.sti.core.extension.constraints.Constraints</code> class, which is the extension of sti-main module and encapsulates user's suggestions for concrete Semantic table interpreter run. The difference is, that Feedback comprises suggestions for all used knowledge bases, but Constraints contain suggestions only for one knowledge base, which is actually used in particular interpreter run.</p><p>Each run of the core algorithm is processed by the <code>TAnnotation uk.ac.shef.dcs.sti.core.algorithm.tmp.TMPOdalicInterpreter.start(Table table, boolean statistical, Constraints constraints)</code> method, which originally did not accept feedbacks, so we added (and implemented) a new argument <code>constraints</code> to this method. We also added another argument <code>statistical</code>, which does not come from Feedback, but from Task configuration. The statistical data annotations part of the Feedback is considered only when the <code>statistical</code> boolean argument is set to <code>true</code>.</p><h1 id="Userfeedback-Subjectcolumnspositions">Subject columns positions</h1><p>User can suggest the positions of the subject columns, which then serve as the subjects for the relation discovery process. The original TableMiner+ algorithm detected the main subject column in the <code>List&lt;Pair&lt;Integer, Pair&lt;Double, Boolean&gt;&gt;&gt; uk.ac.shef.dcs.sti.core.subjectcol.SubjectColumnDetector.compute(Table table, int... skipColumns)</code> method according to the column data-types and other features and did not support manual (user's) setting of the subject columns. Relations were originally discovered only for the subject column detected by that method. Now when the subject columns are suggested by the user, relations are discovered for all of them.</p><h1 id="Userfeedback-Ignoringthecolumn">Ignoring the column</h1><p>User may want to completely ignore the column, so that the column is not annotated (disambiguated/classified) at all and also not considered in relations. This functionality was already supported in the original algorithm and used in all its phases, but we changed the way of passing the information about the indices of columns, which the user wants to ignore, to the algorithm. Originally the indices were set in the configuration file and passed as argument to the constructor of the <code>uk.ac.shef.dcs.sti.core.algorithm.SemanticTableInterpreter</code> object (or inherited class objects). In our implementation we store the column positions in the Feedback (resp. Constraints) class and pass as argument to the <code>start</code> method of the <code>TMPOdalicInterpreter</code> (introduced above). This approach was chosen, because the information about ignored column is part of the same object as other kinds of feedback and can be set individually for each algorithm run.</p><h1 id="Userfeedback-Compulsorycolumns">Compulsory columns</h1><p>The algorithm performs classification and disambiguation phase only for columns where the cells' content data type was recognized as named entity. User may want to compulsorily perform them also when the content does not seem as named entity (e.g. when there are numerical identificators). This functionality was already supported in the original algorithm, but we changed the way of passing the information about the indices of compulsory columns. Originally the indices was set in the configuration file and passed to the constructor of the <code>uk.ac.shef.dcs.sti.core.algorithm.SemanticTableInterpreter</code> object (or inherited classes). We store the positions in the Feedback (resp. Constraints) and pass as argument to the <code>start</code> method of the <code>TMPOdalicInterpreter</code> (the same way as for ignored columns).</p><h1 id="Userfeedback-Ambiguity">Ambiguity</h1><p>User can leave certain cell of the input file ambiguous, meaning that the cell is not disambiguated. The functionality of skipping the cells was implemented in the original algorithm and used in the learning phase in the <code>void uk.ac.shef.dcs.sti.core.algorithm.tmp.LEARNING.learn(Table table,<span> </span>TAnnotation tableAnnotation, int column, Constraints constraints)</code> method, but not utilized in the experimental batches. So we added new argument <code>constraints</code> to this method and the positions of cells, which the user wants to skip, are read from this argument. The reading is provided by the <code>Set&lt;Integer&gt; uk.ac.shef.dcs.sti.core.extension.constraints.Constraints.getSkipRowsForColumn(int columnIndex, int rowsCount)</code> method.</p><h1 id="Userfeedback-ColumnAmbiguity">ColumnAmbiguity</h1><p>This is just a short-cut for leaving all cells in the column ambiguous. It is manifested in the <code>Set&lt;Integer&gt; uk.ac.shef.dcs.sti.core.extension.constraints.Constraints.getSkipRowsForColumn(int columnIndex, int rowsCount)</code> method, which returns all the rows to skip when the ColumnAmbigutity is set for given column.</p><h1 id="Userfeedback-Classification">Classification</h1><p>User can set custom classification resource for the column. In the original algorithm the classification resource is voted according to classes of disambiguated cell values in the <code>Pair&lt;Integer, List&lt;List&lt;Integer&gt;&gt;&gt; uk.ac.shef.dcs.sti.core.algorithm.tmp.LEARNINGPreliminaryColumnClassifier.runPreliminaryColumnClassifier(Table table, TAnnotation tableAnnotation, int column, Constraints constraints, Integer... skipRows)</code> method. So we added new argument <code>constraints</code> to this method, and that extension allowed us to skip the process of voting and just set the annotation chosen by the user. When the user explicitly sets empty classification, then the column is left unclassified. Suggested classifications also affect the process of disambiguation, because in that case the candidates for disambiguation are searched in the knowledge base with the type restriction of respective classification. But when the list of candidates searched with this type restriction is empty, then the candidates are searched again without the type restriction.</p><h1 id="Userfeedback-Disambiguation">Disambiguation</h1><p>User can set custom disambiguation resource for the cell. In the original algorithm the candidate entities are searched in the knowledge base according to the cell value in the <code>void uk.ac.shef.dcs.sti.core.algorithm.tmp.LEARNINGPreliminaryDisamb.runPreliminaryDisamb(int stopPointByPreColumnClassifier, List&lt;List&lt;Integer&gt;&gt; ranking, Table table, TAnnotation tableAnnotation, int column, Constraints constraints, Integer... skipRows)</code> method. So we added new argument <code>constraints</code> to this method. In that extension we also search in the knowledge base, because we need to fetch other attributes of the entity, but we search for just one entity defined by its URI, so the searching is faster and simpler. This also means, that when the user sets entity which does not exist in the knowledge base, we can warn him (in the Warnings part of the Result). Then the entity suggested by user is set as a candidate to the disambiguation algorithm in the same way as it was originally (which was searched according to the cell value) to compute scores. This means that when the suggested entity is not suitable for the cell value disambiguation, it can have the score value of zero, When the user explicitly sets empty disambiguation, the cell is left ambiguous.</p><h1 id="Userfeedback-Relations">Relations</h1><p>User can set custom predicates for relations between columns. In the original algorithm the relation enumeration phase is provided by the <code>void uk.ac.shef.dcs.sti.core.algorithm.tmp.RELATIONENUMERATION.enumerate(List&lt;Pair&lt;Integer, Pair&lt;Double, Boolean&gt;&gt;&gt; subjectColCandidadteScores, Set&lt;Integer&gt; ignoreCols, TColumnColumnRelationEnumerator relationEnumerator, TAnnotation tableAnnotations, Table table, List&lt;Integer&gt; annotatedColumns, UPDATE update, Constraints constraints)</code> method. So we added new argument <code>constraints</code> to this method. In that extension we just add the column relation annotations suggested by user. This  does not restrict the rest of relation discovery process, which can discover relations also between other columns (with consideration of subject column) than the user suggested.</p><h1 id="Userfeedback-Statisticaldataannotations">Statistical data annotations</h1><p>This is our completely new extension. In our implementation the user can denote (in the Task configuration) that the statistical data are processed. In this case the relation enumeration phase is skipped (because columns describe dimensions and measures of the statistical data cube and there are not relations in the strict sense between them). Instead of relations, the statistical annotations are set in the <code>void uk.ac.shef.dcs.sti.core.algorithm.tmp.TMPOdalicInterpreter.setStatisticalAnnotations(List&lt;Integer&gt; annotatedColumns,<span> </span>Table table, TAnnotation tableAnnotations, Constraints constraints)</code> method. Initially the algorithm considers named entity columns as dimensions and non-named entity columns as measures. The user can change this later. Then the user also (manually) sets the predicates which correspond to the columns (dimensions and measures). These annotations are used for RDF export, which is generated according to the RDF data cube standard, where each row of the input file represents one observation and predicates describe dimensions and measures of the observation.</p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 01, 2017 13:30</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
