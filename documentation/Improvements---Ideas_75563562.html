<!DOCTYPE html>
<html>
    <head>
        <title>ADEQUATE : Improvements - Ideas</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">ADEQUATE</a></span>
                            </li>
                                                    <li>
                                <span><a href="Odalic_71438906.html">Odalic</a></span>
                            </li>
                                                    <li>
                                <span><a href="72222608.html">Architecture / Developer Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Odalic-Core_74187556.html">Odalic Core</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            ADEQUATE : Improvements - Ideas
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Tomas Knap</span>, last modified on Mai 26, 2017
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h2 id="Improvements-Ideas-General">General</h2><ul><li>Learning from user feedback: <ul><li><a href="Learning-from-user-feedback_74187386.html">Learning from user feedback</a></li></ul></li><li>Performance of the algorithm (relates to KB search mainly, but also web search probably)<ul><li>first profile what is most time consuming?<ul><li>reduce the Web search</li><li>reduce the context taken into account?<br/><br/></li></ul></li></ul></li></ul><h2 id="Improvements-Ideas-Relations(Vasek)">Relations (Vasek)</h2><p> </p><ul><li><s><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">not taking into account user feedback </span></span></s><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><s><span style="color: rgb(0,0,0);">the algorithm for relation discovery should take into account feedback provided by the user when observing results of the relation discovery algorithm. (done as part of project)</span></s><br/></span></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">try to suggest properties with the domain being equal to the concept classifying the subject column </span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Also it should try to look into relations being already associated with the entities classified with the same class. E.g. if the algorithm knew that column is classified as Country, it should try to map existing properties with the domain Country to the columns with relation values - e.g. it should try to find the column containing population, area (which define the Country as the domain)</span></span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,255);"><span style="color: rgb(0,128,0);">The same for ranges.</span></span></span></span></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">integrate relations discovery in a better way - e.g. so that find relations (and their domain/ranges) influnce the classification and may cause selection of a different class and then different disambigautions. </span></span></li><li><strong><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">For statistical data, it does not run relation discovery.</span></span></strong><ul><li><span style="color: rgb(0,0,0);">But modified version of relation discovery could be executed - it could search just based on the range types e.g. and label and the fact that such predicate is qb:dimensionProperty, qb:measureProperty</span><span style="color: rgb(0,0,0);"><br/></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">taking into account distribution of the values when looking for the property</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">when trying to figure out values of which predicate does certain column contain, it may look into the typical distribution of values. E.g. if there is column containing values such as 1.8, 2.2, 2.0, probably it is not the weight of the person, but rather height of that person.</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,128,0);">This assumes that the classification went wrong, because otherwise I would have a neatly classified Weight or Height column (probably from the headers). Generally it might be interesting to come back to the classification phase again and penalize the classifications that did not result with a successful relation recognition or prefer those that might.</span><br/></span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,128,0);">Yes and No - the numerical value are probably never classified correctly - because they are typically just values of dataType properties</span></span></span></li></ul></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">taking into account recommendations for relations based on the similarity (in terms of the structure) between processed files</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">the algorithm should take into account relations discovered when processing similar files (with similar structure) . For example, if a file A contains relations X, Y, Z and is similar (in terms of the structure) to file B, which contains relations X, Y, it is probable that file B also contains relation Z and such relation should be suggested. </span></span></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">taking into account recommendations for relations based on the fact that certain relations typically occur next to each other. E.g. if there is foaf:firstName, foaf:age, then there may be also foaf:surname</span><br/></span></span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span>inappropriate comparison of potentially relevant relations in the knowledge base</span></span></span></span></span><ul><li><span style="color: rgb(0,0,0);">Low prio: The algorithm may also take account that subject column in the CSV file may be also an object of the triple, not just subject - so it makes sense to look also for inverse relations. </span></li><li><span style="color: rgb(0,0,0);">Low prio: Furthermore, TableMiner+ selects the best matching relation not just based on the comparison of the cell value and object of the triple in the knowledge bases, but also by comparing CSV column title and name/URI of the candidate predicate in the given knowledge base. Nevertheless, in case of two knowledge bases giving evidence for the given relation, the selected predicate should not be taken by just comparing the similarity of the predicate's name and the column title (which may be misleading), but rather by consulting Linked Open Data cloud [5] and selecting more widely used predicate for these situations. </span></li></ul></li><li><span style="color: rgb(0,0,0);">there may be also some notifications, e.g. user suggested certain predicate, but the class to which he tries to assign that is not compatible with the domain of that predicate, etc. </span><span style="color: rgb(0,0,0);"><br/></span></li><li><span style="color: rgb(0,0,0);">? <a href="75563559.html">Story: Provide label for the relations</a></span><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><br/></span></span></li><li><span style="color: rgb(0,0,0);">3-5 focused knowledge bases for the experiments</span></li><li><a href="https://github.com/odalic/sti/issues/175" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/175</a><ul><li>NUTS3 is classified with <a href="http://dbpedia.org/ontology/nutsCode" class="external-link" rel="nofollow">http://dbpedia.org/ontology/nutsCode</a>, which is owl:DatatypeProperty<ul><li><span style="color: rgb(0,0,0);">This relation may make sense, but should not be used as &quot;classification&quot;. </span></li></ul></li><li>identifies relation between LAU_NAME and NUTS3, but it is not correct<ul><li><span style="color: rgb(0,0,0);">the relation &quot;wikiPageWikiLink&quot; is identified in German dbpedia</span></li></ul></li></ul></li><li><span style="color: rgb(0,128,0);">UI of the relations display and management (what works, what not, what and how to improve).</span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,128,0);">Discovery of relations not leading from (or even to) the subject column currently not supported.</span><br/></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,128,0);">Relations when the primary key is split into two or more columns (in other words subject column does not represent the whole primary key) currently not supported.</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,128,0);">Relations across two or more tables (foreign keys, M:N tables) currently not supported.</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,128,0);">What if two columns are classified by the same class? How does the algorithm treat self-relations, e.g. some person is another person's boss?</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,128,0);">Transitive relations. Sometimes a relation between two columns might not map to a single connecting property, but there can be some distance (measured in individual properties) between them?</span><br/></span></li></ul><p> </p><h2 id="Improvements-Ideas-Classification/DisambiguationIssues(Pepa)">Classification/Disambiguation Issues (Pepa)</h2><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><strong>Main focus: </strong></span></span><ul><li><span style="color: rgb(0,0,0);">issues with a user feedback to the classification/disambiguation results of the algorithm</span></li><li><span style="color: rgb(0,0,0);"> </span><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">performance issues with respect to classification/disambiguation</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">other adjustments:</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">too many false positives in case of lower evidence for the disambiguated cells/classified columns or CSV files providing low context for the classified columns/disambiguated cells. </span></span><br/><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><br/></span></span></li></ul></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">If the algorithm does not find any viable candidates for disambiguation for the given class, it tries to ignore it: </span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">This is not the correct way</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">see also: </span></span><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><a href="https://github.com/odalic/sti/issues/440#issuecomment-303812105" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/440#issuecomment-303812105</a><br/></span></span></li><li><span style="color: rgb(0,0,0);"><br/></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">when running on top of COI data - <a href="http://www.coi.cz/userdata/files/dokumenty-ke-stazeni/open-data/kontroly.csv" class="external-link" rel="nofollow">http://www.coi.cz/userdata/files/dokumenty-ke-stazeni/open-data/kontroly.csv</a></span></span><ul><li><span style="color: rgb(0,0,0);">it may happen that there are two possible disambiguations (X,Y) for each cell in the column - but for some, it happens that the disambiguation X is selected, although Y is a type {selected class}, but X is not type of that class. Probably that could happen for the sample - so sample cells are disambiguated, voted for class Z. But then later on the class is re-assigned to Z', but the original disambiguation already remains. </span></li><li><strong><span style="color: rgb(0,0,0);">Cannot reproduce, currently it works ok ( if you select that column contains districts, the proper URL is used)</span></strong></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Performance of the algorithm:</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">the algorithm is slow, probably because of queries to bing OR due to lots of context queries OR due to slow queries to the database (some further index will help?)</span></span><br/><ul><li><span style="color: rgb(0,0,0);">(proposal) too many queries to the knowledge bases during disambiguation caused by ineffective restriction of the searched entities in the knowledge bases</span><span style="color: rgb(0,0,0);"><br/></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">For example, the algorithms for disambiguation typically takes into account the context of the disambiguated cell, such as the row and column in the table the cell is part of. Nevertheless, there is no differentiation among the meaning of the other columns' cells forming the context. For example, if I would disambiguate name of the school, the information about 'locality' (state, country) is really important to reduce the number of entities probed in the knowledge bases and increase precisio</span><br/></span></li></ul></li><li><span style="color: rgb(0,0,0);">propose some improvements</span></li></ul></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Precision of the algorithm: </span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><a href="https://github.com/odalic/sti/issues/175" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/175</a></span></span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Categories should not be used for disambiguation in dbpedia: </span></span><ul><li>Categorie <a href="http://de.dbpedia.org/resource/Kategorie:Gundersdorf" class="external-link" rel="nofollow">http://de.dbpedia.org/resource/Kategorie:Gundersdorf</a> is used to disambiguate city of Gundersdorf, which is not correct. Again, more candidates would be helpful. Categories should not be used!<span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><br/></span></span></li></ul></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span>taking into account distribution of the values when looking for the class of the column </span></span></span></span></span></span><ul><li><span style="color: rgb(0,0,0);">when trying to figure out values of which predicate does certain column contain, it may look into the typical distribution of values. E.g. if there is column containing values such as 1.8, 2.2, 2.0, probably it is not the weight of the person, but rather height of that person.</span><ul><li><span style="color: rgb(0,0,0);"><span><span style="color: rgb(0,128,0);">This assumes that the classification went wrong, because otherwise I would have a neatly classified Weight or Height column (probably from the headers). Generally it might be interesting to come back to the classification phase again and penalize the classifications that did not result with a successful relation recognition or prefer those that might.</span></span></span></li></ul></li></ul><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><br/></span></span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">(proposal) too many false positives in case of lower evidence for the disambiguated cells/classified columns or CSV files providing low context for the classified columns/disambiguated cells.</span></span><br class="_mce_tagged_br"/></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">When there is not enough evidence, do not produce &quot;random&quot; class/diamb, but rather produce no result</span></span></span></li><li><span style="color: rgb(0,0,0);">Algorithm should be extended to work reasonably in the case of lower evidence for the disambiguated cells/classified columns or processing CSV files providing low context for the classified columns/disambiguated cells. For example, when there are too few records in the CSV file, or too few cells were disambiguated, it does not make much sense to try to classify the column, if the cell values are too short and there is no other named entity column, it does not make much sense to disambiguate, or if there is just a couple of different entities in the column, this may be insufficient evidence for the proper classification.</span></li></ul></li></ul></li><li><span style="color: rgb(0,0,0);">If you have a file which contains e.g. name and short-name columns for e.g. IT Companies (see Testing data), then it tries to associate a class with name and short name as well. </span><span style="color: rgb(0,0,0);"><br/></span><ul><li><span style="color: rgb(0,0,0);">but in this case, you would like to e.g. say - based on the name and short name columns create one entity, which has name and short-name. </span></li></ul></li><li>There are situations, when you do not want to classify/disambiguate named entity columns (e.g. when they contain alternative names for e.g. companies - see testing data) - so there should be an option which allows to kind of &quot;ignore&quot; column for class/disambiguation, but which allows to use such column in relations. </li><li>? We can join class/disamb/relation discovery step a bit in a way that it shows data properties for columns with numbers!! So you can denote the column to either contain &quot;class&quot; or value of certain DataProperty. ?</li><li><s>2-3 focused KB</s></li></ul><p> </p><h2 id="Improvements-Ideas-KnowledgeBases(Honza):">Knowledge Bases (Honza): </h2><p> </p><ul><li><strong>Main focus: </strong><br/><ul><li>performance improvements </li><li>proper use of hierarchy of concepts<ul><li>use more specific concepts</li></ul></li><li>other adjustments to KBProxy</li><li>support for GeoNames?</li></ul></li><li><strong>Evaluation:</strong><br/><ul><li>evaluate precision/recall/performance gain<ul><li>evaluate how the precision/recall changed after proper use of hierarchies, other tweaks to KBProxy</li><li>evaluate how the performance improved after adjustments</li></ul></li></ul></li></ul><p> </p><ul><li>Performance:<ul><li>monitoring</li><li><span style="color: rgb(0,0,0);">the algorithm is slow, probably because of queries to bing OR due to lots of context queries OR due to slow queries to the database (some further index will help?)</span></li><li><a href="https://github.com/odalic/sti/issues/256" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/256</a></li></ul></li><li><a href="https://github.com/odalic/sti/issues/312" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/312</a> - No labels for classes with resource not described in the KB<ul><li>how to filter that, get also labels? If it is clickable you may see detail, that would help</li></ul></li><li><strong>Alternative labels not searched when searching KB</strong></li><li>More then one winning concept for disambiguation<ul><li><p>Currently there is just one winning concept for disambiguation when dbpedia is used. It is not a desired behavior but it is so because of the way we query for candidates on dbpedia. </p><ul><li><p>We use exact string match first, and if no match, we use regex. So in most cases, there will be one exact match.</p></li><li>Before with freebase, the search api provided by freebase is like a free text search engine, hence we got many candidates. But because dbpedia is a sparql database and because of the limitation it has w.r.t. text matching, it does not work like freebase.</li><li><p>Ideally, we should firstly build an inverted index of labels of all URIs in dbpedia, and use that instead of doing string matching on labels using sparql.</p></li><li><span style="color: rgb(153,51,102);">We could use an existing full-text index when available.</span></li></ul></li><li>Test on dbpedia</li><li><span style="color: rgb(255,0,0);">Note: Not true, there was an error in the algorithm, should work for now</span></li></ul></li><li>Take into account the hierarchy of KB<ul><li>to favor more concrete classes (TODO example)<ul><li><a href="https://github.com/odalic/sti/issues/259" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/259</a>, <a href="https://github.com/odalic/sti/issues/260" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/260</a></li></ul></li><li>to take into account that certain resource is instance of certain class, which is then subclass of certain class - so to take into account &quot;subclassOf&quot; relations and automatically assume that more generic classes are also candidates. </li></ul></li><li>Efficient search in the KB when searching for alternative concepts  (also solves the issue above with matching the literals) <ul><li>So that it is not based on SPARQL Regex or exact match, but there is inverted index of labels, e.g. stored in Solr, which is fast in terms of full text search<ul><li>So there should be in general an option (controlled in the config file) which may turn on the inteverted index/full text search feature for sparql based repositories, which would improve disambiguation and also e.g. searching the KB.<br/><ul><li>Testing such ability on DBpedia</li><li><span style="color: rgb(153,51,102);">This would mean building the index first, before any other tasks are scheduled?</span></li></ul></li></ul></li></ul></li><li><a href="https://github.com/odalic/sti/issues/291" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/291</a> - Improvements - full text search<span style="color: rgb(153,51,102);"><br/></span></li><li>Take into account other relevant metadata:<ul><li><a href="https://github.com/odalic/sti/issues/55" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/55</a></li></ul></li><li>General KB: <ul><li>Support for Wikidata</li></ul></li><li><span style="color: rgb(0,0,0);">3-5 focused knowledge bases <span style="color: rgb(0,0,0);">(relevant for the data obtained from two Austrian open data catalogs [4,6])</span></span><ul><li><span style="color: rgb(0,0,0);">TODO which datasets?</span><ul><li><span style="color: rgb(0,0,0);"><a href="https://github.com/odalic/sti/issues/173" class="external-link" rel="nofollow">https://github.com/odalic/sti/issues/173</a><br/></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(153,51,102);">We could use a geographical data-set like <a href="http://www.geonames.org/ontology/documentation.html" class="external-link" rel="nofollow">Geonames</a>.</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(153,51,102);"><a href="http://www4.wiwiss.fu-berlin.de/eurostat/" class="external-link" rel="nofollow">KB</a> with the statistical information about European countries.</span><br/></span></li><li>? tweaks for PP KB in ADEQUATe project</li></ul></li><li><span style="color: rgb(0,0,0);">Author should also suggest extensions to the algorithms for classifying, disambiguating, discovering relations, which will better use the knowledge within the knowledge bases</span><ul><li><span style="color: rgb(0,0,0);">TODO particular ideas</span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(153,51,102);">The KB ontology is currently not used in any way. We could prefer classes from the ontology when classifying columns.</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(153,51,102);">Currently the multiple KBs are handled as separate runs of the algorithm. It could be interesting to run the algorithm only once and handle multiple KBs in the KBProxy (return results from all of the configured KBs and merge results with the same URL).</span><br/></span><span style="color: rgb(0,0,0);"><br/></span></li></ul></li></ul><h2 id="Improvements-Ideas-UIImprovements:"><span style="color: rgb(0,0,0);">UI Improvements:</span></h2><ul style="list-style-type: square;"><li><span style="color: rgb(0,0,0);">Definition of a file - hide what is not needed!</span></li><li><span style="color: rgb(0,0,0);">allow user to e.g. adjust which predicate contains labels. Allow users to define new KBs. </span></li></ul><p><span style="color: rgb(0,0,0);"><br/></span></p><h2 id="Improvements-Ideas-Questions:">Questions:</h2><p>How is it with the language tags? Are they taken into account? we tried cs, en, nothing, and the queries were always the same.</p><h2 id="Improvements-Ideas-Other:"><span style="color: rgb(0,0,0);">Other: </span></h2><p><span style="color: rgb(0,0,0);"><br/></span></p><p><span style="color: rgb(0,0,0);"> </span></p><ul><li class="p1"><span class="s1">Pseudocode or simply document the extensions. </span></li></ul><p><span style="color: rgb(0,0,0);"> </span></p><ul class="ul1"><li style="list-style-type: none;background-image: none;"><ul class="ul1"><li class="li1"><span class="s1">user feedback</span></li><li class="li1"><span class="s1">KB search adjustments </span></li></ul></li></ul><p><span style="color: rgb(0,0,0);"> </span></p><p class="p2"> </p><p><span style="color: rgb(0,0,0);"> </span></p><ul><li class="p1"><span class="s1">Minimal Examples where it does not work optimal</span></li></ul><p><span style="color: rgb(0,0,0);"> </span></p><ul class="ul1"><li style="list-style-type: none;background-image: none;"><ul class="ul1"><li class="li1"><span class="s1">e.g. not taking into account hiearchy of KB, taking too generic concept</span></li></ul></li></ul><p><span style="color: rgb(0,0,0);"> </span></p><p class="p2"> </p><p><span style="color: rgb(0,0,0);"> </span></p><ul><li class="p1"><span class="s1">Suggest broader concepts but force to create class</span></li></ul><p><span style="color: rgb(0,0,0);"><br/></span></p><p><span style="color: rgb(0,0,0);"> </span></p><ul><li><span style="color: rgb(0,0,0);">train the conversion algorithm with certain set of products (i.e., manually convert part of the data about products to Linked Data ). Further, the author let the algorithm to convert the rest of the data to Linked Data using the training set and measure the quality of that conversion - to which extent is the resulting data linked to certain concepts in existing knowledge bases (e.g. DBpedia [6] or Wikidata [7]), to which extent the predicates/classes used in the Linked Data correspond to the expectations? </span></li><li><span style="color: rgb(0,0,0);">extend Odalic Core algorithm, so that the algorithm can 1) process the product data obtained from the e-shops, 2) detect predicates (attributes) of the product (e.g. that certain attribute actually contains RAM size) by checking similarity of that attribute's value with the values in the training set and then, based on that, using the detected predicate together with the attribute's value as the object value when Linked Data is generated, 3) detect classes of the products (laptop, phone, etc.) based on the detected predicates, 4) disambiguate values of the attributes against generic Linked Open Data knowledge bases (e.g. DBpedia or Wikidata) and the training set, 5) detect predicates for the rest of the attributes (if we manage to detect that certain product is a laptop, then we know which predicates laptops usually have and can try to match them with the attributes), and 6) properly output the converted data as Linked Data. </span></li></ul><p><span style="color: rgb(0,0,0);"><br/></span></p><p> </p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 01, 2017 13:30</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
