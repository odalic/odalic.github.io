<!DOCTYPE html>
<html>
    <head>
        <title>ADEQUATE : Users - Authentication/Authorization</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">ADEQUATE</a></span>
                            </li>
                                                    <li>
                                <span><a href="Odalic_71438906.html">Odalic</a></span>
                            </li>
                                                    <li>
                                <span><a href="72222608.html">Architecture / Developer Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Odalic-UI_74187672.html">Odalic UI</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            ADEQUATE : Users - Authentication/Authorization
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Tomas Knap</span>, last modified by <span class='editor'> István Satmári</span> on Jan 18, 2017
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p>Requirements:</p><ul><li>Token-based (not cookies based)<ul><li><a class="external-link" href="https://auth0.com/blog/angularjs-authentication-with-cookies-vs-token/" rel="nofollow" style="text-decoration: underline;">https://auth0.com/blog/angularjs-authentication-with-cookies-vs-token/</a></li></ul></li><li>module/library which may use later easily OAuth</li><li>Token by mely splnovat: <a href="https://jwt.io/introduction/" class="external-link" rel="nofollow">https://jwt.io/introduction/</a> </li></ul><p> </p><p>Notes: </p><ul><li>Token based auth, based on existing approaches (frontend 1d, backend 2-3d),<ul><li>token-based authentication module for <a class="external-link" href="http://angularjs.org/" rel="nofollow">AngularJS</a> with built-in support for Google, Facebook, LinkedIn, Twitter, Instagram, GitHub, Bitbucket, Yahoo, Twitch, Microsoft <a class="external-link" href="https://github.com/sahat/satellizer" rel="nofollow" style="text-decoration: underline;">https://github.com/sahat/satellizer</a></li><li>server side example: <a class="external-link" href="https://github.com/sahat/satellizer/tree/master/examples/server/java" rel="nofollow">https://github.com/sahat/satellizer/tree/master/examples/server/java</a><ul><li>Note: persistence of users!  (in a same way as tasks, i.e. to a file as RDF data?)</li></ul></li><li>Take into account that we may need later in the ADEQUATe project to use OAuth - so there is a central authority responsible for management of accounts, so instead of just inserting name/pass, we should be able to ask that authority for code<ul><li><a class="external-link" href="https://github.com/sahat/satellizer" rel="nofollow" style="text-decoration: underline;">satellizer</a> enables to use use OAuth later</li></ul></li></ul></li><li>user registers and logs in - using the module above and proper persistence. </li><li>roles: user is either admin - may see everything (cannot be registered, but has to be defined manually, by manually adjusting the files) OR he is a normal user, may see only his tasks.<ul><li>to somehow filter the<strong> list of configurations</strong> (extension to the API to list the configuration based on the user/token provided) (1-2d?)<ul><li>it could really just filter, so if the user is already able to see execution, than no one is checking whether he can edit/delete/run execution. </li></ul></li><li><strong>? list of files</strong> - should be also filtered based on the logged user. (extension to the API to provide also user/token as a param)<ul><li>be careful not to complicate too much - can the user change change/delete file prepared by someone else?</li><li>I would suggest to keep the cache for files for ALL. (if needed we may hide the list of files view, so that users are not scared that other will see their files easily)</li></ul></li></ul></li><li>Note: Token based vs. cookie based<ul><li><a class="external-link" href="https://auth0.com/blog/angularjs-authentication-with-cookies-vs-token/" rel="nofollow">https://auth0.com/blog/angularjs-authentication-with-cookies-vs-token/</a></li></ul></li></ul><p>---</p><h3 id="Users-Authentication/Authorization-SATELLIZERhttps://github.com/sahat/satellizer#authgettoken">SATELLIZER <a href="https://github.com/sahat/satellizer#authgettoken" class="external-link" rel="nofollow">https://github.com/sahat/satellizer#authgettoken</a></h3><p>Tested, works rather well with AngularJS.Not tested thoroughly though; a proper server response is not implemented, yet.</p><p>Presumably<strong> &quot;Login with Email and Password&quot; </strong>will be mostly used, though we can allow OAuth 2.0 authentication as well <em>(logging in with an existing Google/Facebook/GitHub/... account)</em>. I tested OAuth 2.0 against Google; seems to be working. This may take some time to properly set up, however, so I am not sure about going this way. If you are interested, here is a documentation about setting OAuth 2.0 with Google: <a href="https://support.google.com/cloud/answer/6158849?hl=en" class="external-link" rel="nofollow">https://support.google.com/cloud/answer/6158849?hl=en</a> Obviously approach for FB / GitHub / ... differs.</p><p>Flow for the <strong>&quot;Login with Email and Password&quot;</strong> from &quot;github.com/sahat&quot;:</p><ul><li><strong>Client:</strong> Enter your email and password into the login form.</li><li><strong>Client:</strong> On form submit call <code>$auth.login()</code> with email and password.</li></ul><pre><span style="color: rgb(0,0,128);">var </span><span style="color: rgb(69,131,131);">user </span>= {<br/>    <span style="color: rgb(102,14,122);">email</span>: <span style="color: rgb(0,128,0);">'istvan.satmari@gmail.com'</span>,<br/>    <span style="color: rgb(102,14,122);">password</span>: <span style="color: rgb(0,128,0);">'example'<br/></span>};<br/><br/>$auth.<span style="color: rgb(122,122,67);">login</span>(<span style="color: rgb(69,131,131);">user</span>)<br/>    .<span style="color: rgb(122,122,67);">then</span>(<span style="color: rgb(0,0,128);">function</span>(response) {<br/>        <span style="color: rgb(102,14,122);">console</span>.<span style="color: rgb(122,122,67);">log</span>(<span style="color: rgb(0,128,0);">'login successful!'</span>);<br/>        <span style="color: rgb(102,14,122);">console</span>.<span style="color: rgb(122,122,67);">log</span>(response);<br/>    })<br/>    .<span style="color: rgb(122,122,67);">catch</span>(<span style="color: rgb(0,0,128);">function</span>(response) {<br/>        <span style="color: rgb(102,14,122);">console</span>.<span style="color: rgb(122,122,67);">log</span>(<span style="color: rgb(0,128,0);">'login failure!'</span>);<br/>    });</pre><ul><li><strong>Client:</strong> Send a <code>POST</code> request to <code>/auth/login</code>.</li></ul><p>Not necessarily to &quot;<code>/auth/login</code>.&quot;, may be overriden by following statement:</p><pre><span class="pl-smi">$authProvider</span>.<span class="pl-smi">loginUrl</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>/myauth/login<span class="pl-pds">'</span></span>;</pre><ul><li><strong>Server:</strong> Check if email exists, if not - return <code>401</code>.</li><li><strong>Server:</strong> Check if password is correct, if not - return <code>401</code>.</li><li><strong>Server:</strong> Create a JSON Web Token and send it back to the client.</li></ul><p>I am going to use a node.js example from <a href="https://github.com/sahat/satellizer/blob/master/examples/server/node/server.js" class="external-link" rel="nofollow">https://github.com/sahat/satellizer/blob/master/examples/server/node/server.js</a> (Yes, I understand we use Java server, but this example was a little bit more readable for me. I assume the approach will be quite similar.)</p><pre>// Upon receiving the POST request to '/<span class="pl-s">myauth</span>/login':<br/>app.post('/<span class="pl-s">myauth</span>/login', function(req, res) {<br/>  // We search for the given user, presumably in a DB according to &quot;email&quot; from request body.<br/>  // Request body looks like this:  <br/>  // <span style="color: rgb(69,131,131);">req.body =</span> { <span style="color: rgb(102,14,122);">email</span>: <span style="color: rgb(0,128,0);">'istvan.satmari@<a href="http://gmail.com" class="external-link" rel="nofollow">gmail.com</a>'</span>, <span style="color: rgb(102,14,122);">password</span>: <span style="color: rgb(0,128,0);">'example'</span> };<br/>  User.findOne({ email: req.body.email }, '+password', function(err, user) {<br/>    if (!user) {<br/>      return res.status(401).send({ message: 'Invalid email and/or password' });<br/>    }<br/>    user.comparePassword(req.body.password, function(err, isMatch) {<br/>      if (!isMatch) {<br/>        return res.status(401).send({ message: 'Invalid email and/or password' });<br/>      }<br/>  <br/>      // Found him! (And there is a match in provided passwords)<br/>      // Return the response. ('user' object is probably constructed from data from the DB? ...)<br/>      res.send({ token: createJWT(user) });<br/>    });<br/>  });<br/>});</pre><pre>// Returns the object to send back to client upon 'login'<br/>function createJWT(user) {<br/>  var payload = {<br/>    // I assume 'user._id' is identical to the user's e-mail from login request<br/>    sub: user._id,<br/>    iat: moment().unix(),<br/>    exp: moment().add(14, 'days').unix()<br/>  };<br/><br/>  // Now we return the JSON object using an external JWT library.<br/>  // config: a config file. TOKEN_SECRET: 'YOUR_UNIQUE_JWT_TOKEN_SECRET' (random sequence of characters; our 'private key')<br/>  return jwt.encode(payload, config.TOKEN_SECRET);</pre><pre>}</pre><p>I assume an assymetrical cryptography is used here <em>(automatically by JWT library)</em> and this flow:</p><ul><li>The payload is encrypted using 'private key' and returned to the client.</li><li>Client uses 'public key' and decrypts the response from the server. This way we also have a 'free' check of server authenticity - i.e. whether was the server not an 'imposter'.</li><li>The client saves the response; this will be its token.</li><li>Any consequent request to the server has to be <em>signed</em> by this token.</li></ul><ul><li><strong>Client:</strong> Parse the token and save it to <em>Local Storage</em> for subsequent use after page reload.</li></ul><p> </p><p>Now any consequent request is handled on the server like this:</p><pre>// Let's assume &quot;GET http://.../api/me&quot; REST method; privileged, returning data about ourselves, i.e. about current user. Will be configured like this:<br/>app.get('/api/me', ensureAuthenticated, function(req, res) {<br/>  // &quot;ensureAuthenticated&quot; method ensures the client is properly authenticated. The method also fills the &quot;req.user&quot; object.<br/><br/>  // We again search for the user in a DB and return the data as a response:<br/>  User.findById(req.user, function(err, user) {<br/>    // 'user' object comes from the DB; we send it to client. We send nothing else, i.e. just the data requested.<br/>    res.send(user);<br/>  });<br/>});</pre><p>Checking whether the user is already authenticated:</p><pre>function ensureAuthenticated(req, res, next) {<br/>  // The request needs to have 'Authorization' header:<br/>  if (!req.header('Authorization')) {<br/>    return res.status(401).send({ message: 'Please make sure your request has an Authorization header' });<br/>  }<br/>  var token = req.header('Authorization').split(' ')[1];<br/><br/>  var payload = null;<br/>  try {<br/>    // We decrypt the token sent by the client using either public or private key (it does not matter). This way we get the payload object we constructed earlier inside the &quot;createJWT&quot; method.<br/>    payload = jwt.decode(token, config.TOKEN_SECRET);<br/>  }<br/>  catch (err) {<br/>    // The client faked the token which we recognized easily.<br/>    return res.status(401).send({ message: err.message });<br/>  }<br/><br/>  // Did the token expire?<br/>  if (payload.exp &lt;= moment().unix()) {<br/>    return res.status(401).send({ message: 'Token has expired' });<br/>  }<br/><br/>  // Fill the 'req.user' object with the data about the currently logged in user.<br/>  req.user = payload.sub;<br/>} </pre><p> I may not be completely right about the flow, so please, do check the documentation on <a href="https://jwt.io/" class="external-link" rel="nofollow">https://jwt.io/</a> .</p><p>Some information about the JWT may also be found here: <a href="http://robmclarty.com/blog/what-is-a-json-web-token" class="external-link" rel="nofollow">http://robmclarty.com/blog/what-is-a-json-web-token</a></p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 01, 2017 13:30</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
