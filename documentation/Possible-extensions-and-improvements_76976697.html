<!DOCTYPE html>
<html>
    <head>
        <title>ADEQUATE : Possible extensions and improvements</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">ADEQUATE</a></span>
                            </li>
                                                    <li>
                                <span><a href="Odalic_71438906.html">Odalic</a></span>
                            </li>
                                                    <li>
                                <span><a href="ODALIC-Documentation_76973575.html">ODALIC Documentation</a></span>
                            </li>
                                                    <li>
                                <span><a href="Developer-Documentation_76973577.html">Developer Documentation</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            ADEQUATE : Possible extensions and improvements
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Václav Brodec</span>, last modified on Jun 01, 2017
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h1 id="Possibleextensionsandimprovements-Algorithm">Algorithm</h1><h2 id="Possibleextensionsandimprovements-Learningfromtheuserfeedback">Learning from the user feedback</h2><p>In general, the algorithm should be able to learn from feedbacks provided by the users:<span> </span></p><ul><li><span>When certain classification is marked as being wrong for file X, column C, then we can learn from that and in the future penalize such classification for documents with same/similar structure. </span></li><li><span>The same for a chosen alternative, which could be prioritized in similar conditions.<br/></span></li><li>Use the already executed classifications/disambiguations/relations discoveries as a learning set of cases in supervised learning and try to deduce classifications/disambiguations/relations discoveries for the other cases based on that.</li></ul><h2 id="Possibleextensionsandimprovements-Differentkindsoffeedback">Different kinds of feedback</h2><p>Apart from the feedback where user essentially overrules the algorithm, allow the user to provide a negative feedback, marking some resources as undesirable, but let the algorithm to try alternatives.</p><h2 id="Possibleextensionsandimprovements-Generalperformance">General performance</h2><ul><li>Find a better balance between the context taken into account and the number of queries.</li><li>Reduce the usage of web search API.</li><li>Enable parallel processing of interpreters and cooperative interruption of tasks.</li></ul><h2 id="Possibleextensionsandimprovements-Relationsdiscovery">Relations discovery</h2><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Try to suggest properties with the domain being equal to the concept classifying the subject column.</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Also it should try to look into relations being already associated with the entities classified with the same class, e.g. if the algorithm knew that column is classified as Country, it should try to map existing properties with the domain Country to the columns with relation values - in other words it should try to find a column containing population, area (which define the Country as the domain).</span></span></span></li><li><span style="color: rgb(51,51,51);">The same for ranges.</span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Integrate relations discovery in a better way - e.g. so that found relations (and their domain/ranges) influence the classification and may cause selection of a different class and then different disambiguations.</span></span></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">For statistical data, the algorithm does not run relation discovery.</span></span><ul><li><span style="color: rgb(0,0,0);">But modified version of relation discovery could be executed - it could search the range types, and use the fact that every such predicate is qb:dimensionProperty, qb:measureProperty</span><span style="color: rgb(0,0,0);">.<br/></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Taking into account distribution of the values when looking for the property.</span></span><ul><li><span style="color: rgb(0,128,0);"><span style="color: rgb(0,0,0);">E.g. if there is a column containing values such as &quot;1.8&quot;, &quot;2.2&quot;, &quot;2.0&quot;, it probably is not weight of a person, but rather his or her height.</span></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Taking into account recommendations for relations based on the similarity (in terms of the structure) between processed files.</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">For example if file A contains relations X, Y, Z and it is similar (in terms of its structure) to file B, which contains relations X, Y, it is probable that file B also contains relation Z and such relation should be suggested. </span></span></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Taking into account recommendations for relations based on the fact that certain relations typically occur next to each other. E.g. When there are properties foaf:firstName and foaf:age, then there probably is also property foaf:surname</span>.</span></span></span><span style="color: rgb(0,0,0);"> </span></li><li><span style="color: rgb(0,0,0);">The algorithm may also take account that subject column in the CSV file may be also an object of some triple, not just the subject - so it makes sense to also look for inverse relations. </span></li><li><span style="color: rgb(0,0,0);">Algorithm selects the best matching relation not just based on the comparison of the cell value and object of the triple in the knowledge bases, but also by comparing CSV column title and name/URI of the candidate predicate in the given knowledge base. Nevertheless, in case of two knowledge bases giving evidence for the given relation, the selected predicate should not be taken by just comparing the similarity of the property name and the column title (which may be misleading), but rather by consulting <a href="http://lod-cloud.net/" class="external-link" rel="nofollow">Linked Open Data cloud</a> and selecting more widely used predicate for these situations.</span></li><li><span style="color: rgb(0,0,0);">Detect common violations of the established vocabularies, such is not respecting domains and ranges of the properties, when changing the classifications of related columns.</span><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"> </span></span><span style="color: rgb(0,0,0);"> </span><span style="color: rgb(0,128,0);"> </span><span style="color: rgb(0,0,0);"><br/></span></li><li><span style="color: rgb(51,51,51);">Relations when the primary key is split into two or more columns (in other words subject column does not represent the whole &quot;primary key&quot;) currently is not supported.</span></li><li><span style="color: rgb(51,51,51);">Enable of processing of sets of tables and detect relations across two or more tables (foreign keys, M:N tables).</span></li><li><span style="color: rgb(51,51,51);">Explore algorithm behaviour in certain corner cases:</span><ul><li><span style="color: rgb(51,51,51);">What if two columns are classified by the same class? How to introduce handling of self-relations, e.g. some person is another person's boss?</span></li></ul></li><li><span style="color: rgb(51,51,51);">Use the vocabularies to infer other relations.</span></li></ul><h2 id="Possibleextensionsandimprovements-Classification/Disambiguation">Classification/Disambiguation</h2><ul><li><span style="color: rgb(0,0,0);">There are still some issues with the user feedback to the classification/disambiguation results of the algorithm:</span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Cells with the same literal value share the same disambiguation, which is the first one resolved.<br/></span></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Performance issues with respect to classification/disambiguation,</span></span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">T<span style="color: rgb(0,0,0);">oo many queries to the knowledge bases during disambiguation caused by ineffective restriction of the searched entities in the knowledge bases</span><span style="color: rgb(0,0,0);">.</span></span></span><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"> For example, the algorithm for disambiguation typically takes into account the context of the disambiguated cell, such as the row and column in the table the cell is part of. Nevertheless, there is no differentiation among the meaning of the other columns' cells forming the context. For example, if I would disambiguate name of the school, the information about 'locality' (state, country) is really important to reduce the number of entities probed in the knowledge bases and it would also increase precision.</span></span></li></ul></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">Too many false positives in case of lower evidence for the disambiguated cells/classified columns or CSV files providing low context for the classified columns/disambiguated cells.</span></span></li><li>Take into account the distribution of values.</li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">When there is not enough evidence, do not produce the almost arbitrary classification or disambiguation, but rather produce no result.</span></span></span></li><li><span style="color: rgb(0,0,0);">If you have a file which contains name and abbreviation, then the algorithm tries to associate the same class with the name and abbreviation at the same time.</span><span style="color: rgb(0,0,0);"> But in this case one of the columns should be chosen as the preferred one, and the other one to become a property of the first one.</span></li></ul><h2 id="Possibleextensionsandimprovements-KnowledgeBases">Knowledge Bases</h2><ul><li>Proper use of hierarchy of concepts.</li><li>Improve the behaviour to always select the most specific concepts</li><li>Support for GeoNames base and Wikidata.</li><li>Do a rigorous evaluation:<br/><ul><li>Evaluate precision/recall/performance gain.</li><li>Evaluate how the precision/recall changed after proper use of hierarchies, other tweaks to <code>KBProxy</code>.</li><li>Evaluate how the performance improved after adjustments.</li></ul></li></ul><ul><li>Alternative labels are not searched when searching the bases.<strong><br/></strong></li><li>Provide more then one winning concept for disambiguation.<br/><ul><li><p>Currently there is just one winning concept for disambiguation when e.g. DBpedia is used. It is not a desire<span style="color: rgb(51,51,51);">d behaviour, but it is so because of the way the queries for candidates are made.</span></p><ul><li><p><span style="color: rgb(51,51,51);">We use exact string match first, and if no matching resource is found, we use regular expression. So in most cases, there will be one exact match.</span></p></li><li><span style="color: rgb(51,51,51);">Before with the now deprecated Freebase, the search API was more similar to a free text engine, hence we got many candidates. But DBpedia is a SPARQL database and therefore has the text matching comparatively limited.</span></li><li><p><span style="color: rgb(51,51,51);">Ideally, we should first build an inverted index of labels of all URIs in DBpedia, and use that instead of doing string matching on labels using SPARQL or we we could use an existing full-text index when available.</span></p></li></ul></li></ul></li><li><span style="color: rgb(51,51,51);">Take into account the hierarchy of KB.</span><br/><ul><li><span style="color: rgb(51,51,51);">Follow the &quot;subclassOf&quot; relations and automatically assume that more generic classes are also candidates.</span><ul><li><span style="color: rgb(51,51,51);">Unfortunately this relations have to materialized first.</span></li></ul></li></ul></li><li><span style="color: rgb(51,51,51);">Currently the multiple KBs are handled as separate runs of the algorithm. It could be interesting to run the algorithm only once and handle multiple KBs in the KBProxy (return results from all of the configured KBs and merge results with the same URL).</span><ul><li><span style="color: rgb(0,0,0);"><span style="color: rgb(153,51,102);"><span style="color: rgb(51,51,51);">At least allow parallel execution, but with respect to the shared resources (hard-drive and network access).</span></span></span></li></ul><span style="color: rgb(0,0,0);"><span style="color: rgb(153,51,102);"> </span></span></li></ul><h1 id="Possibleextensionsandimprovements-UIImprovements"><span style="color: rgb(0,0,0);">UI Improvements</span></h1><ul><li><span style="color: rgb(0,0,0);"> </span><span style="color: rgb(0,0,0);">Introduce graph visualisation for data cube export.<br/></span></li><li><span style="color: rgb(0,0,0);">Prevent the roll-on effect in some less used browsers when the screens change.</span></li><li><span style="color: rgb(0,0,0);">Add user administration module to the UI.</span></li><li><span style="color: rgb(0,0,0);">Improve token generation and management:</span><ul><li><span style="color: rgb(0,0,0);">Allow the user to overview the issued tokens.</span></li></ul></li><li><span style="color: rgb(0,0,0);">Use <a href="https://oauth.net/" class="external-link" rel="nofollow">OAuth</a> and external services to log the users in.</span></li><li><span style="color: rgb(0,0,0);">Adapt <a href="https://github.com/dvcama/LodView" class="external-link" rel="nofollow">LodView</a> or other means to view the details of resources.<br/></span></li></ul><p style="margin-left: 30.0px;"><span style="color: rgb(0,0,0);"> </span></p><p> </p><p> </p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jun 01, 2017 13:30</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
